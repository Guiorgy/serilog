using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
#if DEBUG
using System.Diagnostics;
#endif
using System.Text;

namespace SourceGenerators
{
    [Generator]
    internal sealed partial class LoggerInterfaceSourceGenerator : ISourceGenerator
    {
        private const bool Debug = false;
        private const string Tab = "    ";
        private static readonly string NewLine = new StringBuilder().AppendLine().ToString();

        private const string ClassFormat = @"// <auto-generated/>
using System.Diagnostics;

namespace {0};

{1} {2} {3}
{{
{4}
}}

";

        /*
         * 0: tab
         * 1: exception documentation comment (prefixed with newline or empty)
         * 2: propertyValue(s/0..n) documentation comment (prefixed with newline or empty)
         * 3: generic parameters (with brackets or empty)
         * 4: exception parameter (prefixed with a comma or empty)
         * 5: propertyValue(s/0..n) parameter(s) (prefixed with a comma or empty)
         * 6: exception argument (prefixed with a comma or empty)
         * 7: propertyValue(s/0..n) argument(s)
         */
        private const string WriteMethodTemplate = @"{0}/// <summary>
{0}/// Write a log event with the specified level.
{0}/// </summary>
{0}/// <param name=""level"">The level of the event.</param>{1}
{0}/// <param name=""messageTemplate"">Message template describing the event.</param>{2}
{0}[MessageTemplateFormatMethod(""messageTemplate"")]
{0}void Write{3}(LogEventLevel level{4}, string messageTemplate{5})
#if FEATURE_DEFAULT_INTERFACE
{0}{{
{0}{0}// Avoid the array allocation and any boxing allocations when the level isn't enabled
{0}{0}if (IsEnabled(level))
{0}{0}{{
{0}{0}{0}Write(level{6}, messageTemplate, {7});
{0}{0}}}
{0}}}
#else
{0}{0};
#endif";

        private static readonly string ExceptionDocumentationComment = $"{NewLine}{Tab}/// <param name=\"exception\">Exception related to the event.</param>";

        public void Execute(GeneratorExecutionContext context)
        {
#if DEBUG
            if (Debug && !Debugger.IsAttached) Debugger.Launch();
#endif

            var receiver = (ClassOrInterfaceAttributeSyntaxReceiver)context.SyntaxReceiver!;

            foreach (var capture in receiver.Captures)
            {
                if (capture.InterfaceDeclaration == null) continue;

                var semanticModel = context.Compilation.GetSemanticModel(capture.InterfaceDeclaration.SyntaxTree);
                (var genericOverrideCount, var logEventLevels) = GetAttributeArguments(semanticModel, capture.AttributeDeclaration);

                var methodSources = new StringBuilder();

                // Write method without exception and without propertyValues
                methodSources.AppendFormat(WriteMethodTemplate, Tab,
                    /* exception doccumentation comment */ "",
                    /* propertyValue(s/0..n) documentation comment */ "",
                    /* generic parameters */ "",
                    /* exception parameter */ "",
                    /* propertyValue(s/0..n) parameter(s) */ "",
                    /* exception argument */ "",
                    /* propertyValue(s/0..n) argument(s) */ "NoPropertyValues"
                ).AppendLine().AppendLine();

                // Write method with exception and without propertyValues
                methodSources.AppendFormat(WriteMethodTemplate, Tab,
                    /* exception doccumentation comment */ ExceptionDocumentationComment,
                    /* propertyValue(s/0..n) documentation comment */ "",
                    /* generic parameters */ "",
                    /* exception parameter */ ", Exception? exception",
                    /* propertyValue(s/0..n) parameter(s) */ "",
                    /* exception argument */ ", exception",
                    /* propertyValue(s/0..n) argument(s) */ "NoPropertyValues"
                ).AppendLine().AppendLine();

                // Write generic methods with and without exception, and with propertyValue(s)
                if (genericOverrideCount != 0)
                {
                    var propValueComments = new StringBuilder().AppendLine().Append(Tab);
                    var genericParams = new StringBuilder().Append('<');
                    var propValueProps = new StringBuilder().Append(", ");
                    var newArrayValues = new StringBuilder().Append("new object?[] { ");

                    for (int i = 0; i < genericOverrideCount; i++)
                    {
                        // skip "0" when we only have 1 propertyValue
                        string istr = i == 0 ? "" : i.ToString();

                        if (i == 1)
                        {
                            // return the "0" we skipped above
                            propValueComments.Replace("propertyValue", "propertyValue0");
                            genericParams.Append(0);
                            propValueProps.Replace("T propertyValue", "T0 propertyValue0");
                            newArrayValues.Append(0);
                        }

                        if (i != 0)
                        {
                            propValueComments.AppendLine().Append(Tab);
                            genericParams.Append(", ");
                            propValueProps.Append(", ");
                            newArrayValues.Append(", ");
                        }

                        propValueComments.Append("/// <param name=\"propertyValue").Append(istr)
                            .Append("\">Object positionally formatted into the message template.</param>");
                        genericParams.Append('T').Append(istr).Append('>');
                        propValueProps.Append('T').Append(istr).Append(" propertyValue").Append(istr);
                        newArrayValues.Append("propertyValue").Append(istr).Append(" }");

                        // Write method with exception and without propertyValues
                        methodSources.AppendFormat(WriteMethodTemplate, Tab,
                            /* exception doccumentation comment */ ExceptionDocumentationComment,
                            /* propertyValue(s/0..n) documentation comment */ propValueComments,
                            /* generic parameters */ genericParams,
                            /* exception parameter */ ", Exception? exception",
                            /* propertyValue(s/0..n) parameter(s) */ propValueProps,
                            /* exception argument */ ", exception",
                            /* propertyValue(s/0..n) argument(s) */ newArrayValues
                        ).AppendLine().AppendLine();

                        // Write method without exception and without propertyValues
                        methodSources.AppendFormat(WriteMethodTemplate, Tab,
                            /* exception doccumentation comment */ "",
                            /* propertyValue(s/0..n) documentation comment */ propValueComments,
                            /* generic parameters */ genericParams,
                            /* exception parameter */ "",
                            /* propertyValue(s/0..n) parameter(s) */ propValueProps,
                            /* exception argument */ "",
                            /* propertyValue(s/0..n) argument(s) */ newArrayValues
                        ).AppendLine().AppendLine();

                        genericParams.Length--; // undo last .Append('<')
                        newArrayValues.Length -= 2; // undo last .Append(" }")
                    }
                }

                Console.WriteLine(logEventLevels);

                methodSources.Length -= NewLine.Length * 2; // undo last 2 .AppendLine()

                var source = string.Format(ClassFormat, capture.Namespace, capture.Modifiers, capture.Keyword, capture.Name, methodSources.ToString());

                context.AddSource($"{capture.Name}.generated.cs", source);
            }
        }

        public void Initialize(GeneratorInitializationContext context)
        {
#if DEBUG
            if (Debug && !Debugger.IsAttached) Debugger.Launch();
#endif

            context.RegisterForSyntaxNotifications(() => new ClassOrInterfaceAttributeSyntaxReceiver("LoggerGenerateAttribute"));
        }

        private static (int GenericOverrideCount, string[] LogLevels) GetAttributeArguments(SemanticModel semanticModel, AttributeSyntax attribute)
        {
            if (attribute.ArgumentList!.Arguments.Count != 2) throw new SourceGeneratorException("Argument count mismatch");

            var genericOverrideCountArgument = attribute.ArgumentList!.Arguments[0];
            var genericOverrideCountExpression = genericOverrideCountArgument.Expression;
            var genericOverrideCountOptional = semanticModel.GetConstantValue(genericOverrideCountExpression);
            if (!genericOverrideCountOptional.HasValue || genericOverrideCountOptional.Value == null) throw new SourceGeneratorException("Failed to parse 'genericOverrideCount' argument");
            var genericOverrideCount = (int)genericOverrideCountOptional.Value;

            var logEventLevelsArgument = attribute.ArgumentList!.Arguments[1];
            var logEventLevelsExpression = logEventLevelsArgument.Expression;
            var logEventLevelsOptional = semanticModel.GetConstantValue(logEventLevelsExpression);
            if (!logEventLevelsOptional.HasValue || logEventLevelsOptional.Value == null) throw new SourceGeneratorException("Failed to parse 'logEventLevels' argument");
            var logEventLevels = logEventLevelsOptional.Value.ToString();

            return (genericOverrideCount, logEventLevels.Split(',').Select(l => l.Trim()).ToArray());
        }
    }
}

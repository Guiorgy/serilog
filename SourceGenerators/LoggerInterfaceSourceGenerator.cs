using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
#if DEBUG
using System.Diagnostics;
#endif
using System.Text;

namespace SourceGenerators
{
    [Generator]
    internal sealed partial class LoggerInterfaceSourceGenerator : ISourceGenerator
    {
        private const bool Debug = false;
        private const string Tab = "    ";
        private static readonly string NewLine = new StringBuilder().AppendLine().ToString();

        private const string ClassFormat = @"// <auto-generated/>
#nullable enable

namespace {0};

{1} {2} {3}
{{
{4}
}}

";

        /*
         * 0: tab
         * 1: exception documentation comment (prefixed with newline or empty)
         * 2: propertyValue(s/0..n) documentation comment (prefixed with newline or empty)
         * 3: generic parameters (with brackets or empty)
         * 4: exception parameter (postfixed with a comma or empty)
         * 5: propertyValue(s/0..n) parameter(s) (prefixed with a comma or empty)
         * 6: exception argument (prefixed with a comma or empty)
         * 7: propertyValue(s/0..n) argument(s)
         */
        private const string WriteMethodTemplate = @"{0}/// <summary>
{0}/// Write a log event with the specified level.
{0}/// </summary>
{0}/// <param name=""level"">The level of the event.</param>{1}
{0}/// <param name=""messageTemplate"">Message template describing the event.</param>{2}
{0}[MessageTemplateFormatMethod(""messageTemplate"")]
{0}void Write{3}(LogEventLevel level, {4}string messageTemplate{5})
#if FEATURE_DEFAULT_INTERFACE
{0}{{
{0}{0}// Avoid the array allocation and any boxing allocations when the level isn't enabled
{0}{0}if (IsEnabled(level))
{0}{0}{{
{0}{0}{0}Write(level{6}, messageTemplate, {7});
{0}{0}}}
{0}}}
#else
{0}{0};
#endif";

        /*
         * 0: tab
         * 1: exception documentation comment (prefixed with newline or empty)
         * 2: propertyValue(s/0..n) documentation comment (prefixed with newline or empty)
         * 3: generic parameters (with brackets or empty)
         * 4: exception parameter (postfixed with a comma or empty)
         * 5: propertyValue(s/0..n) parameter(s) (prefixed with a comma or empty)
         * 6: exception argument (prefixed with a comma or empty)
         * 7: propertyValue(s/0..n) argument(s)
         * 8: LogEventLevel
         * 9: LogEventLevel argument (or empty)
         * 10: example code
         * 11: forwarded method
         */
        private const string LevelMethodTemplate = @"{0}/// <summary>
{0}/// Write a log event with the <see cref=""LogEventLevel.{8}""/> level and associated exception.
{0}/// </summary>{1}
{0}/// <param name=""messageTemplate"">Message template describing the event.</param>{2}
{0}/// <example><code>
{0}/// {10}
{0}/// </code></example>
{0}[MessageTemplateFormatMethod(""messageTemplate"")]
{0}void {8}{3}({4}string messageTemplate{5})
#if FEATURE_DEFAULT_INTERFACE
{0}{0}=> {11}({9}{6}, messageTemplate, {7})
#endif
{0};";

        private static readonly Dictionary<string, string> ExampleCodesWithoutException = new()
        {
            { "Verbose", "Log.Verbose(\"Staring into space, wondering if we're alone.\");" },
            { "Debug", "Log.Debug(\"Starting up at {StartedAt}.\", DateTime.Now);" },
            { "Information", "Log.Information(\"Processed {RecordCount} records in {TimeMS}.\", records.Length, sw.ElapsedMilliseconds);" },
            { "Warning", "Log.Warning(\"Skipped {SkipCount} records.\", skippedRecords.Length);" },
            { "Error", "Log.Error(\"Failed {ErrorCount} records.\", brokenRecords.Length);" },
            { "Fatal", "Log.Fatal(\"Process terminating.\");" },
        };

        private static readonly Dictionary<string, string> ExampleCodesWithException = new()
        {
            { "Verbose", "Log.Verbose(ex, \"Staring into space, wondering where this comet came from.\");" },
            { "Debug", "Log.Debug(ex, \"Swallowing a mundane exception.\");" },
            { "Information", "Log.Information(ex, \"Processed {RecordCount} records in {TimeMS}.\", records.Length, sw.ElapsedMilliseconds);" },
            { "Warning", "Log.Warning(ex, \"Skipped {SkipCount} records.\", skippedRecords.Length);" },
            { "Error", "Log.Error(ex, \"Failed {ErrorCount} records.\", brokenRecords.Length);" },
            { "Fatal", "Log.Fatal(ex, \"Process terminating.\");" },
        };

        private static readonly string ExceptionDocumentationComment = $"{NewLine}{Tab}/// <param name=\"exception\">Exception related to the event.</param>";
        private const string ExceptionParameter = "Exception? exception, ";
        private const string ExceptionArgument = ", exception";

        private static readonly string PropertyValuesObjectArrayDocumentationComment = $"{NewLine}{Tab}/// <param name=\"propertyValues\">Objects positionally formatted into the message template.</param>";
        private const string PropertyValuesObjectArrayProperty = ", params object?[]? propertyValues";
        private const string NotPropertyValues = "NoPropertyValues";

        private const string WriteMethod = "Write";

        public void Execute(GeneratorExecutionContext context)
        {
#if DEBUG
            if (Debug && !Debugger.IsAttached) Debugger.Launch();
#endif

            var receiver = (ClassOrInterfaceAttributeSyntaxReceiver)context.SyntaxReceiver!;

            foreach (var capture in receiver.Captures)
            {
                if (capture.InterfaceDeclaration == null) continue;

                var semanticModel = context.Compilation.GetSemanticModel(capture.InterfaceDeclaration.SyntaxTree);
                (var genericOverrideCount, var logEventLevels) = GetAttributeArguments(semanticModel, capture.AttributeDeclaration);

                var methodSources = new StringBuilder();

                // Write method without exception and without propertyValues
                methodSources.AppendFormat(WriteMethodTemplate, Tab,
                    /* exception doccumentation comment */ "",
                    /* propertyValue(s/0..n) documentation comment */ "",
                    /* generic parameters */ "",
                    /* exception parameter */ "",
                    /* propertyValue(s/0..n) parameter(s) */ "",
                    /* exception argument */ "",
                    /* propertyValue(s/0..n) argument(s) */ NotPropertyValues
                ).AppendLine().AppendLine();

                // Write method with exception and without propertyValues
                methodSources.AppendFormat(WriteMethodTemplate, Tab,
                    /* exception doccumentation comment */ ExceptionDocumentationComment,
                    /* propertyValue(s/0..n) documentation comment */ "",
                    /* generic parameters */ "",
                    /* exception parameter */ ExceptionParameter,
                    /* propertyValue(s/0..n) parameter(s) */ "",
                    /* exception argument */ ExceptionArgument,
                    /* propertyValue(s/0..n) argument(s) */ NotPropertyValues
                ).AppendLine().AppendLine();

                // generic Write methods with and without exception, and with propertyValue(s)
                if (genericOverrideCount != 0)
                {
                    var propValueComments = new StringBuilder().AppendLine().Append(Tab);
                    var genericParams = new StringBuilder().Append('<');
                    var propValueParams = new StringBuilder().Append(", ");
                    var newArrayValues = new StringBuilder().Append("new object?[] { ");

                    for (int i = 0; i < genericOverrideCount; i++)
                    {
                        // skip "0" when we only have 1 propertyValue
                        string istr = i == 0 ? "" : i.ToString();

                        if (i == 1)
                        {
                            // return the "0" we skipped above
                            propValueComments.Replace("propertyValue", "propertyValue0");
                            genericParams.Append(0);
                            propValueParams.Replace("T propertyValue", "T0 propertyValue0");
                            newArrayValues.Append(0);
                        }

                        if (i != 0)
                        {
                            propValueComments.AppendLine().Append(Tab);
                            genericParams.Append(", ");
                            propValueParams.Append(", ");
                            newArrayValues.Append(", ");
                        }

                        propValueComments.Append("/// <param name=\"propertyValue").Append(istr)
                            .Append("\">Object positionally formatted into the message template.</param>");
                        genericParams.Append('T').Append(istr).Append('>');
                        propValueParams.Append('T').Append(istr).Append(" propertyValue").Append(istr);
                        newArrayValues.Append("propertyValue").Append(istr).Append(" }");

                        // Write method without exception and with generic propertyValues
                        methodSources.AppendFormat(WriteMethodTemplate, Tab,
                            /* exception doccumentation comment */ "",
                            /* propertyValue(s/0..n) documentation comment */ propValueComments,
                            /* generic parameters */ genericParams,
                            /* exception parameter */ "",
                            /* propertyValue(s/0..n) parameter(s) */ propValueParams,
                            /* exception argument */ "",
                            /* propertyValue(s/0..n) argument(s) */ newArrayValues
                        ).AppendLine().AppendLine();

                        // Write method with exception and with generic propertyValues
                        methodSources.AppendFormat(WriteMethodTemplate, Tab,
                            /* exception doccumentation comment */ ExceptionDocumentationComment,
                            /* propertyValue(s/0..n) documentation comment */ propValueComments,
                            /* generic parameters */ genericParams,
                            /* exception parameter */ ExceptionParameter,
                            /* propertyValue(s/0..n) parameter(s) */ propValueParams,
                            /* exception argument */ ExceptionArgument,
                            /* propertyValue(s/0..n) argument(s) */ newArrayValues
                        ).AppendLine().AppendLine();

                        genericParams.Length--; // undo last .Append('>')
                        newArrayValues.Length -= 2; // undo last .Append(" }")
                    }
                }

                foreach (var logEvenLevel in logEventLevels)
                {
                    // method without exception and with propertyValues as an object array
                    methodSources.AppendFormat(LevelMethodTemplate, Tab,
                        /* exception doccumentation comment */ "",
                        /* propertyValue(s/0..n) documentation comment */ PropertyValuesObjectArrayDocumentationComment,
                        /* generic parameters */ "",
                        /* exception parameter */ "",
                        /* propertyValue(s/0..n) parameter(s) */ PropertyValuesObjectArrayProperty,
                        /* exception argument */ "(Exception?)null",
                        /* propertyValue(s/0..n) argument(s) */ "propertyValues",
                        /* LogEventLevel */ logEvenLevel,
                        /* LogEventLevel argument */ "",
                        /* example code */ ExampleCodesWithoutException[logEvenLevel],
                        /* forwarded method */ logEvenLevel
                    ).AppendLine().AppendLine();

                    // method without exception and without propertyValues
                    methodSources.AppendFormat(LevelMethodTemplate, Tab,
                        /* exception doccumentation comment */ "",
                        /* propertyValue(s/0..n) documentation comment */ "",
                        /* generic parameters */ "",
                        /* exception parameter */ "",
                        /* propertyValue(s/0..n) parameter(s) */ "",
                        /* exception argument */ "",
                        /* propertyValue(s/0..n) argument(s) */ NotPropertyValues,
                        /* LogEventLevel */ logEvenLevel,
                        /* LogEventLevel argument */ $"LogEventLevel.{logEvenLevel}",
                        /* example code */ ExampleCodesWithoutException[logEvenLevel],
                        /* forwarded method */ WriteMethod
                    ).AppendLine().AppendLine();

                    // method with exception and without propertyValues
                    methodSources.AppendFormat(LevelMethodTemplate, Tab,
                        /* exception doccumentation comment */ ExceptionDocumentationComment,
                        /* propertyValue(s/0..n) documentation comment */ "",
                        /* generic parameters */ "",
                        /* exception parameter */ ExceptionParameter,
                        /* propertyValue(s/0..n) parameter(s) */ "",
                        /* exception argument */ ExceptionArgument,
                        /* propertyValue(s/0..n) argument(s) */ NotPropertyValues,
                        /* LogEventLevel */ logEvenLevel,
                        /* LogEventLevel argument */ $"LogEventLevel.{logEvenLevel}",
                        /* example code */ ExampleCodesWithException[logEvenLevel],
                        /* forwarded method */ WriteMethod
                    ).AppendLine().AppendLine();

                    // method with exception and with propertyValues as an object array
                    methodSources.AppendFormat(LevelMethodTemplate, Tab,
                        /* exception doccumentation comment */ ExceptionDocumentationComment,
                        /* propertyValue(s/0..n) documentation comment */ PropertyValuesObjectArrayDocumentationComment,
                        /* generic parameters */ "",
                        /* exception parameter */ ExceptionParameter,
                        /* propertyValue(s/0..n) parameter(s) */ PropertyValuesObjectArrayProperty,
                        /* exception argument */ ExceptionArgument,
                        /* propertyValue(s/0..n) argument(s) */ "propertyValues",
                        /* LogEventLevel */ logEvenLevel,
                        /* LogEventLevel argument */ $"LogEventLevel.{logEvenLevel}",
                        /* example code */ ExampleCodesWithException[logEvenLevel],
                        /* forwarded method */ WriteMethod
                    ).AppendLine().AppendLine();

                    // generic methods with and without exception, and with propertyValue(s)
                    if (genericOverrideCount != 0)
                    {
                        var propValueComments = new StringBuilder().AppendLine().Append(Tab);
                        var genericParams = new StringBuilder().Append('<');
                        var propValueParams = new StringBuilder().Append(", ");
                        var propValueForwardArgs = new StringBuilder();

                        for (int i = 0; i < genericOverrideCount; i++)
                        {
                            // skip "0" when we only have 1 propertyValue
                            string istr = i == 0 ? "" : i.ToString();

                            if (i == 1)
                            {
                                // return the "0" we skipped above
                                propValueComments.Replace("propertyValue", "propertyValue0");
                                genericParams.Append(0);
                                propValueParams.Replace("T propertyValue", "T0 propertyValue0");
                                propValueForwardArgs.Append(0);
                            }

                            if (i != 0)
                            {
                                propValueComments.AppendLine().Append(Tab);
                                genericParams.Append(", ");
                                propValueParams.Append(", ");
                                propValueForwardArgs.Append(", ");
                            }

                            propValueComments.Append("/// <param name=\"propertyValue").Append(istr)
                                .Append("\">Object positionally formatted into the message template.</param>");
                            genericParams.Append('T').Append(istr).Append('>');
                            propValueParams.Append('T').Append(istr).Append(" propertyValue").Append(istr);
                            propValueForwardArgs.Append("propertyValue").Append(istr);

                            // method without exception and with generic propertyValues
                            methodSources.AppendFormat(LevelMethodTemplate, Tab,
                                /* exception doccumentation comment */ "",
                                /* propertyValue(s/0..n) documentation comment */ propValueComments,
                                /* generic parameters */ genericParams,
                                /* exception parameter */ "",
                                /* propertyValue(s/0..n) parameter(s) */ propValueParams,
                                /* exception argument */ "",
                                /* propertyValue(s/0..n) argument(s) */ propValueForwardArgs,
                                /* LogEventLevel */ logEvenLevel,
                                /* LogEventLevel argument */ $"LogEventLevel.{logEvenLevel}",
                                /* example code */ ExampleCodesWithoutException[logEvenLevel],
                                /* forwarded method */ WriteMethod
                            ).AppendLine().AppendLine();

                            // method with exception and with generic propertyValues
                            methodSources.AppendFormat(LevelMethodTemplate, Tab,
                                /* exception doccumentation comment */ ExceptionDocumentationComment,
                                /* propertyValue(s/0..n) documentation comment */ propValueComments,
                                /* generic parameters */ genericParams,
                                /* exception parameter */ ExceptionParameter,
                                /* propertyValue(s/0..n) parameter(s) */ propValueParams,
                                /* exception argument */ ExceptionArgument,
                                /* propertyValue(s/0..n) argument(s) */ propValueForwardArgs,
                                /* LogEventLevel */ logEvenLevel,
                                /* LogEventLevel argument */ $"LogEventLevel.{logEvenLevel}",
                                /* example code */ ExampleCodesWithException[logEvenLevel],
                                /* forwarded method */ WriteMethod
                            ).AppendLine().AppendLine();

                            genericParams.Length--; // undo last .Append('>')
                        }
                    }
                }

                methodSources.Length -= NewLine.Length * 2; // undo last 2 .AppendLine()

                var source = string.Format(ClassFormat, capture.Namespace, capture.Modifiers, capture.Keyword, capture.Name, methodSources.ToString());

                context.AddSource($"{capture.Name}.generated.cs", source);
            }
        }

        public void Initialize(GeneratorInitializationContext context)
        {
#if DEBUG
            if (Debug && !Debugger.IsAttached) Debugger.Launch();
#endif

            context.RegisterForSyntaxNotifications(() => new ClassOrInterfaceAttributeSyntaxReceiver("LoggerGenerateAttribute"));
        }

        private static (int GenericOverrideCount, string[] LogLevels) GetAttributeArguments(SemanticModel semanticModel, AttributeSyntax attribute)
        {
            if (attribute.ArgumentList!.Arguments.Count != 2) throw new SourceGeneratorException("Argument count mismatch");

            var genericOverrideCountArgument = attribute.ArgumentList!.Arguments[0];
            var genericOverrideCountExpression = genericOverrideCountArgument.Expression;
            var genericOverrideCountOptional = semanticModel.GetConstantValue(genericOverrideCountExpression);
            if (!genericOverrideCountOptional.HasValue || genericOverrideCountOptional.Value == null) throw new SourceGeneratorException("Failed to parse 'genericOverrideCount' argument");
            var genericOverrideCount = (int)genericOverrideCountOptional.Value;

            var logEventLevelsArgument = attribute.ArgumentList!.Arguments[1];
            var logEventLevelsExpression = logEventLevelsArgument.Expression;
            var logEventLevelsOptional = semanticModel.GetConstantValue(logEventLevelsExpression);
            if (!logEventLevelsOptional.HasValue || logEventLevelsOptional.Value == null) throw new SourceGeneratorException("Failed to parse 'logEventLevels' argument");
            var logEventLevels = logEventLevelsOptional.Value.ToString();

            return (genericOverrideCount, logEventLevels.Split(',').Select(l => l.Trim()).ToArray());
        }
    }
}
